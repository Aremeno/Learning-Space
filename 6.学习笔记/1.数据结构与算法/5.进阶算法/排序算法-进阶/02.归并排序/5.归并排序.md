# 归并排序

归并排序（Merge Sort）是一种基于分治法的排序算法，其基本思想是将一个大数组分成两个小数组，分别对这两个小数组进行排序，然后将排序好的小数组合并成一个有序的大数组。

## 算法步骤

1. **分解**：将数组**递归**地分成两半，直到每个子数组只包含一个元素（一个元素的数组是有序的）。
2. **合并**：将两个有序的子数组合并成一个有序的数组。具体步骤如下：
   - 创建一个临时数组用于存放合并后的结果。
   - 使用两个指针分别指向两个子数组的起始位置，比较两个指针所指向的元素，将较小的元素放入临时数组中，并移动对应的指针。
   - 重复上述步骤，直到其中一个子数组的所有元素都被放入临时数组中。
   - 将另一个子数组中剩余的元素全部放入临时数组中。
   - 将临时数组的内容复制回原数组。

## 代码实现

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 合并函数（返回合并后的数组（已排序好））

vector<int> mergeArrays(const vector<int>& left,const vector<int>& right) {
    vector<int> result;
    int i = 0,j = 0;

    // 遍历比较并将较小的元素放入结果数组
    while(i < left.size() && j < right.size()) {
        if (left[i] < right[j]) {
            result.push_back(left[i]);
            i++;
        } else {
            result.push_back(right[j]);
            j++;
        }
    }

    // 添加剩余元素

    while (i < left.size()) {
        result.push_back(left[i]);
        i++;
    }
    while(j < right.size()) {
        result.push_back(right[j]);
        j++;
    }

    return result;
}

// 归并排序函数

vector<int> mergesort(const vector<int>& arr) {
    // 处理数组为空或者仅有一个元素的情况
    if (arr.size() <= 1) {
        return arr;
    }

    // 找到中间点
    int mid = arr.size() / 2;

    // 分割数组
    vector<int> left(arr.begin(),arr.begin() + mid);
    vector<int> right(arr.begin() + mid,arr.end());

    // 递归排序
    left = mergesort(left);
    right = mergesort(right);

    return mergeArrays(left,right);
}
```

## 复杂度分析

- 时间复杂度：归并排序的时间复杂度为 O(n log n)，其中 n 是数组的元素数量。因为每次分割数组需要 log n 次，而每次合并需要 O(n)的时间。
- 空间复杂度：归并排序的空间复杂度为 O(n)，因为在合并过程中需要额外的临时数组来存放合并后的结果。

## 应用场景总结

### 链表排序

归并排序非常适合用于链表的排序，因为链表的随机访问效率较低，而归并排序只需要顺序访问。通过递归地分割链表并合并，可以高效地对链表进行排序（**可以将空间复杂度优化到 O(1)**）。

### 稳定排序

归并排序是一种稳定的排序算法，即在排序过程中不会改变相等元素的相对顺序（某些应用场景需要保持稳定性）。

### 大数据排序

归并排序适用于处理大数据集，尤其是当数据量大到无法全部加载到内存中时。通过外部归并排序，可以将数据分块排序后再进行合并，从而实现对大数据集的排序。

### 并行计算和分布式排序

归并排序的分治思想使其非常适合并行计算和分布式排序。可以将数据分割成多个子任务，分别在不同的处理器或节点上进行排序，然后再合并结果，提高排序效率。

### 顺序访问

归并排序在需要顺序访问数据的场景中表现良好，例如磁盘存储的数据排序，因为它减少了随机访问的次数，提高了效率。