# 选择排序

## 简单介绍

选择排序比较简单直观，就是从未排序区间内找到最小（或最大）元素，把它放到已排序区间的末尾，重复到完成排序即可。

具体过程如下：

1. 所有元素都没有排序，所以未排序区间是整个数组。
2. 找到数组中最小的元素，和第一个元素进行交换，此时未排序区间右移一位。
3. 重复步骤2，直到未排序区间为空。
4. 且最后一个元素自然也是最大的，无需再进行比较。，故右移到倒数第二个元素即可。

下面是选择排序的C实现：

```c
#include <stdio.h>
void void select_sort(int arr[],int size){
    for(int i = 0;i<size-1;i++){
        int min_index = i;
        for(int j = i+1;j<=size;j++){
            if(arr[j] < arr[min_index]){
                min_index=j;
                continue;
            }
        }
        if(min_index == i){
            continue;
        }
        int temp = arr[i];
        arr[i] = arr[min_index];
        arr[min_index] = temp;
    }
}
```

## 复杂度分析

- 时间复杂度为O(n^2)，为非适应性排序算法（无论数组是否有序，时间复杂度都一样）。
- 空间复杂度为O(1)，为原地排序算法（直接在数组上进行排序）。
- 稳定性：不稳定排序算法（相同元素的相对位置可能会改变）。
- 适用场景：数据量较小，且对稳定性要求不高的排序场景。

