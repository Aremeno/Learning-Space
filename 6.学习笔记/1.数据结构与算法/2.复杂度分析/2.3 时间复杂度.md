# 2.3 时间复杂度

如何准确预估一段代码的运行时间：

1. **确定运行平台**：硬件配置、编程语言、系统环境等因素都会影响代码的运行效率。
2. **统计各操作的执行次数与时间**：各种操作的所需时间是一定的，然后统计每个操作执行的次数即可计算执行总时间。

但实际上，**统计算法实际运行时间是不合理也不现实的**。  
因此，引入了时间复杂度的概念。

## 2.3.1 初识时间复杂度

时间复杂度分析的是**算法运行时间随着数据量变大时的增长趋势**。 

如何理解“时间增长趋势”呢？以下为一个实例：

```c
void algorithm_A(int n){
    printf("%d",0);//算法A（常数阶）
}
void algorithm_B(int n){
    for(int i=0;i<n;i++)
        printf("%d",0);//算法B（线性阶）
}
void algorithm_C(int n){
    for (int i = 0;i <1000000;i++){
        printf("%d",0);//算法C（常数阶）
    }
}
```

在上述代码中：

- **算法A**：因为只有一个打印操作，所以算法运行时间不会随着n增大而增长。这种时间复杂度为“常数阶”。
- **算法B**：这里的打印操作需要循环n次，随着n的增大，算法运行时间呈线性增长。这种时间复杂度为“线性阶”。
- **算法C**：虽然打印操作循环了一百万次，但是和n无关，所以它的时间复杂度和`A`是相同的，故也是“常数阶”。

时间复杂度图示：

![时间复杂度图示](https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_simple_example.png)

**时间复杂度的特点**：

- **有效性**：时间复杂度可以有效评估算法效率。
- **便捷性**：可以简单地把所有操作的执行时间视为相同的“单位时间”，从而只需要统计操作次数即可。
- **局限性**：时间复杂度只关注增长趋势，但是有些时候实际运行速度却是相反的。

## 2.3.2 函数渐进上界

若操作次数是关于n的一次函数，那说明运行时间的增长趋势是线性的，也就是时间复杂度是线性阶。

我们将线性阶表示为O(n)，这个数学符号称为<u>大O符号</u>，表示函数的<u>渐进上界</u>。

**什么是“渐进上界”呢？**  
若存在正实数c和n0，使得对于所有n≥n0，都有f(n)≤c*g(n)，则称g(n)为f(n)的一个渐进上界，记作f(n)=O(g(n))。

由此可见，**时间复杂度推算时，完全可以忽略常数项和低阶项，由操作次数中最高阶项决定。**

## 2.3.3 常见时间复杂度

常见时间复杂度由以下几种：

1. 常数阶 O(1)
2. 对数阶 O(log n)
3. 线性阶 O(n)
4. 线性对数阶 O(n log n)
5. 平方阶 O(n^2)
6. 指数阶 O(2^n)
7. 阶乘阶 O(n!)

**注意**：以上按照时间复杂度从低到高排序。

### 1. 常数阶 O(1)

常数阶的操作数量与输入数据n无关。  
**但不意味着操作数量很少**。也就是说无论操作数量为多少，只要与n无关，时间复杂度都是O(1)。

### 2. 线性阶 O(n)

常见于单层循环。遍历数组、链表等数据结构时，时间复杂度通常也为O(n)。  
但是**输入数据大小n需要根据输入的数据结构来定义**。比如：数组长度、输入数据大小等。
