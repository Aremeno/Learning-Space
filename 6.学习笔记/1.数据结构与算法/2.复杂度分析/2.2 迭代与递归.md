# 2.2 迭代与递归

在算法中，重复执行某些操作是常见的需求，这与复杂度分析密切相关。  
**那么如何实现重复执行任务呢？**

主要有两种方式：迭代和递归。

## 2.2.1 迭代

迭代是一种重复执行某个任务的控制结构。在迭代中，程序会在满足特定条件下重复执行一段代码块，直到条件不再满足为止。  
**说实话，其实就是在语言中学过的循环结构。**

**那与复杂度分析有什么关系呢？**

迭代的时间复杂度通常与循环次数成正比。  
比如一层循环就是“线性关系”，两层循环就是“平方关系”。每一次嵌套都是一次“升维”。

## 2.2.2 递归

<u>递归是一种算法策略</u>，它通过函数调用自身来解决问题。它主要包括两个阶段：

1. **递**：程序不断调用自身，逐渐将参数简化或更小化，直到达到“终止条件”。
2. **归**：当达到“终止条件”后，程序从最深层的调用开始返回结果，汇聚每一层的结果，最终得到最终答案。

可知递归代码主要包含三个要素：

1. **终止条件**：用于决定什么时候由“递”转为“归”。
2. **递归调用**：函数在自身内部调用自身。
3. **返回结果**：每次递归调用返回一个结果，最终汇聚成最终答案。

（计算 1 到 n 的和）代码演示：

```c
int recur(int n){
    // 终止条件
    if(n==1)
        return 1;
    // 递
    int res = recur(n-1);
    // 归
    return n + res;
}
```

**该函数递归过程图示**：

![递归过程图示](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum.png)

## 2.2.3 迭代与递归的比较

虽然二者得到的结果是一样的，**但是代表了两种完全不同的思考和解决问题的范式。**

- **迭代**：“自上而下”地解决问题。每次循环基础步骤，逐渐逼近最终结果。
- **递归**：“自下而上”地解决问题。将大问题拆解成小问题，并逐步拆解，直到达到最简单的情况，然后逐步汇聚结果。

比如计算 1 到 n 的和（设函数 f(n)=1+2+...+n）：

- **迭代**：从 1 开始，逐步累加到 n。
- **递归**：就是先拆成 f(n)=n+f(n-1)，然后继续拆 f(n-1)，直到 f(1)=1 为止，然后逐步汇聚结果。

### 1.调用栈

递归函数每次调用自身时，都会为新开启的函数分配内存。这将导致：

- 只有函数返回后，内存才会释放。因此，**递归通常比迭代更加耗费内存空间**。
- 递归调用函数会产生额外的时间开销。**因此递归通常比循环的时间效率更低**。

**递归深度**：递归调用的层数。**允许的递归深度是有限的，过深的递归会导致栈溢出错误**。

### 2.尾递归

尾递归是对普通递归的一种优化。在尾递归中，**递归调用时函数返回前的最后一个操作**，这意味着，函数返回上一层级时，不需要保留当前函数的状态，因为没有其他操作需要执行，因而就不需要分配新的栈帧。

仍以计算 1 到 n 的和为例，尾递归的实现如下：

```c
int tailRecur(int n, int res){
    // 终止条件
    if(n==1)
        return res + 1;//这里的res就是存储和
    // 递归调用是函数的最后一个操作
    return tailRecur(n-1, res + n);
}
```

**该函数尾递归过程图示**：

![尾递归过程图示](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/tail_recursion_sum.png)

### 3.递归树

当处理与“分治”相关的算法问题时，递归往往比迭代更为直观和简洁。  
以斐波那契数列为例：

```c
int fib(int n){
    //终止条件（前两个值）
    if (n==0 || n==1)
    return n;
    //递归调用
    int res = fib(n-1) + fib(n-2);
    //返回结果
    return res;
}
```

**该函数递归树图示**：

```plaintext
          fib(5)
         /      \
     fib(4)      fib(3)
     /   \       /    \
 fib(3) fib(2) fib(2) fib(1)
  / \     |      |      |
fib(2) fib(1)  1      1
 / \
1   1
```

### 小结

下表总结了迭代与递归的主要区别：

|          | 迭代                   | 递归                                     |
| -------- | ---------------------- | ---------------------------------------- |
| 实现方式 | 通过循环结构实现       | 通过函数调用自身实现                     |
| 时间效率 | 效率通常较高           | 每次调用有额外开销，效率较低             |
| 空间效率 | 通常使用固定大小的内存 | 需要额外的栈空间，空间消耗较大           |
| 适用场景 | 适用于简单重复任务     | 适用于子问题分解，如树、图、分治、回溯等 |

**递归与迭代的选择取决于特定问题的性质。**
