# 差分

差分也是一种**预处理技术**，下面介绍了差分的简单原理及其应用。

## 什么是差分

说白了，差分就是**相邻两个元素之间的差值**，下面仍以零花钱的例子来说明差分的概念。

```text
原数组： a[1] = 2, a[2] = 5, a[3] = 9, a[4] = 15, a[5] = 22
差分数组： d[1] = a[1] = 2
          d[2] = a[2] - a[1] = 5 - 2 = 3
          d[3] = a[3] - a[2] = 9 - 5 = 4
          d[4] = a[4] - a[3] = 15 - 9 = 6
          d[5] = a[5] - a[4] = 22 - 15 = 7
```

## 解决的核心问题

差分主要用来解决**批量修改**的问题：比如现在要给第 2 天到第 4 天的零花钱每天增加 3 元，传统方法与差分方法的对比如下：

```cpp
// 传统方法-要循环3次
for (int i = 2; i <= 4; i++) {
    a[i] += 3;
}
// 差分方法-只要修改两个位置
d[2] += 3;     // 从第2天开始每天增加3元
d[5] -= 3;     // 从第5天开始每天减少3元（相当于第4天之后不增加了）
```

## 为什么有效

也许你会问，差分方法为什么只修改两个位置就能达到批量修改的效果呢？不要急，我们来分析一下：

```text
d[i] = a[i] - a[i-1]
现在我们要给 a[l] 到 a[r] 每个元素增加 x，那么差分数组 d 的变化如下：
- a[l] 增加 x，意味着 d[l] 也要增加 x，因为 d[l] = a[l] - a[l-1]
- a[r+1] 不变，意味着 d[r+1] 要减少 x，因为 d[r+1] = a[r+1] - a[r]，而 a[r] 增加了 x
- 其他位置的 d[i] 不变，因为它们都既加又减了
```

**因此,只需要记住关键公式：**

- 要对区间 [l, r] 增加 x：
  - d[l] += x
  - d[r + 1] -= x

## 恢复原数组

当我们完成所有的差分修改后，如何恢复出原数组呢？这时我们只需要进行一次前缀和操作：

```cpp
a[1] = d[1];
for (int i = 2; i <= n; i++) {
    a[i] = a[i - 1] + d[i];
}
```

## 完整代码示例

针对上述的零花钱例子，下面是一个完整的代码示例：

```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n = 5; // 天数
    vector<int> a = {0, 2, 5, 9, 15, 22}; // 原数组，a[0] 未使用
    vector<int> d(n + 2, 0); // 差分数组，多开一个位置防止越界

    // 构建差分数组
    d[1] = a[1];
    for (int i = 2; i <= n; i++) {
        d[i] = a[i] - a[i - 1];
    }

    // 批量修改：给第2天到第4天每天增加3元
    int l = 2, r = 4, x = 3;
    d[l] += x;
    d[r + 1] -= x;

    // 恢复原数组
    a[1] = d[1];
    for (int i = 2; i <= n; i++) {
        a[i] = a[i - 1] + d[i];
    }

    // 输出结果
    for (int i = 1; i <= n; i++) {
        cout << "Day " << i << ": " << a[i] << " yuan" << endl;
    }

    return 0;
}
```
