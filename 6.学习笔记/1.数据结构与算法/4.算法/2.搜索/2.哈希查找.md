# 哈希查找

通常，我们通过将线性查找替换为哈希查找来降低算法的时间复杂度。

以下借助一个算法题来说明：

> 题目：给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 `target` 的那 两个 整数，并返回它们的数组下标。返回任意一个解即可。

## 线性查找

我们可以使用两层循环来实现线性查找：

```cpp
class Solution {
    public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            for (int j = i + 1; j < size; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
}
```

该算法的时间复杂度为 O(n^2)，当数组规模较大时，效率较低。

## 哈希优化

```cpp
class Solution {
    public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 创建哈希表(用于存储数组元素及其对应的下标)
        unordered_map<int, int> hashTable;
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            int complement = target - nums[i];
            // 检查哈希表中是否存在与当前元素互补的元素
            if (hashTable.find(complement) != hashTable.end()) {
                return {hashTable[complement], i};
            }
            // 将当前元素及其下标存入哈希表
            hashTable.emplace(nums[i],i);
        }
        return {};
    }
}
```