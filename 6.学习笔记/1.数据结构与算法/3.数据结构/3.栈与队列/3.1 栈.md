# 栈

栈是一种线性数据结构，它遵循先入后出（LIFO, Last In First Out）的逻辑。

形象来说，栈类似于一叠盘子，只能操作最后放上去的盘子。

我们将堆叠元素的顶部称为“栈顶”，将底部称为“栈底”。添加元素到栈顶的操作称为“入栈”（push），从栈顶移除元素的操作称为“出栈”（pop）。

## 栈的常用操作

一般情况下，我们会直接使用编程语言内置的栈类。当然如果语言没有内置栈类，也可以用“数组”或“链表”来实现栈。

下面以C++为例：

```cpp
#include <stack>

using namespace std;

stack<int> s; // 创建一个存储整数的栈

s.push(10); // 入栈元素10
s.push(20); // 入栈元素20
s.push(30); // 入栈元素30

int topElement = s.top(); // 获取栈顶元素（30）
s.pop(); // 出栈（移除栈顶元素30）

int size = s.size(); // 获取栈的大小（2）
bool isEmpty = s.empty(); // 检查栈是否为空（false）
```

## 栈的实现

下面用C语言来实现一个简单的栈，用于理解栈的底层原理。

很明显，栈只能在栈顶进行操作，因此可以把栈顶看做一个**受限的数组或链表**。

### 链表实现栈：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int val;
    struct ListNode *next;
} ListNode;

typedef struct {
    ListNode *top;
    int size;
} Stack;

// 构造函数

Stack* stackCreate() {
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    stack->top = NULL;
    stack->size = 0;
    return stack;
}

// 析构函数

void stackFree(Stack* stack) {
    whlie(stack->top){
        ListNode* temp = stack->top;
        stack->top = stack->top->next;
        free(temp);
    }
    free(stack);
}

// 获取栈的长度

int stackSize(Stack* stack) {
    return stack->size;
}

// 判断栈是否为空

bool stackIsEmpty(Stack* stack) {
    return stackSize(stack) == 0;
}

// 入栈操作

void stackPush(Stack* stack,int num) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = num;
    node->next = stack->top;
    stack->top = node;
    stack->size++;
}

// 访问栈顶元素

int stackPeek(Stack* stack){
    if(stackIsEmpty(stack)){
        return -1; // 栈为空时返回-1
    }
    return stack->top->val;
}

// 出栈操作

int stackPop(Stack* stack) {
    if(stackIsEmpty(stack)){
        return -1; // 栈为空时返回-1
    }
    ListNode* temp = stack->top;
    int val = stackPeek(stack);
    stack->top = stack->top->next;
    free(temp);
    stack->size--;
    return val;
}
```

### 数组实现栈：

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
// 基于数组实现的栈

typedef struct {
    int *data;
    int size;
} ArrayStack;

ArrayStack *ArrayStackcreat() {
    ArrayStack *stack = malloc(sizeof(ArrayStack));
    stack->data = malloc(sizeof(int) * MAX_SIZE);
    stack->size = 0;
    return stack;
}

// 析构函数

void ArrayStackfree(ArrayStack *stack) {
    free(stack->data);
    //为什么要free这个data，因为stack只包含一个指针，指向data，但是动态数组data里的数据也是动态分配的内存，需要释放
    free(stack);
}

// 获取栈的长度

int size(ArrayStack *stack) {
    return stack->size;
}

// 判断栈是否为空

bool isEmpty(ArrayStack *stack) {
    return size(stack) == 0;
}

// 入栈操作

void ArrayStackPush(ArrayStack *stack,int num) {
    if (stack->size == MAX_SIZE) {
        printf("栈已满，无法入栈\n");
        return;
    }
    stack->data[stack->size] = num;
    stack->size++;
}

// 出栈操作

int ArrayStackPop(ArrayStack *stack) {
    if(stack->size == 0) {
        printf("栈为空，无法出栈\n");
        return -1; // 栈为空时返回-1
    }
    int val = stack->data[stack->size - 1];
    stack->size--;
    return val;
}

/* 出栈操作解释：这里把size这个计数器减一，
  看似没有把数据真正删除，但是返回的这个数据
  已经不在栈的范围内了，下一次入栈会覆盖掉这个数据，
  所以逻辑上来说这个数据已经被删除了。 */

// 访问栈顶元素

int ArrayStackPeak(ArrayStack *stack) {
    if (stack->size == 0) {
        printf("栈为空，无法访问栈顶元素\n");
        return -1; // 栈为空时返回-1
    }
    return stack->data[stack->size - 1];
}
```
