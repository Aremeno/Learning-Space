# 链表（Linked List）

## 1. 链表的定义

<u>链表</u>，线性数据结构，内存非连续存储。

**组成单位**：节点（Node）对象。每个节点都包含两项数据：数据域（Data）和指针域（Pointer）。

- 链表的第一个节点称为“头节点”（Head），最后一个节点（尾节点）的指针域指向空（Null）。
- 链表中的节点通过指针域连接在一起，形成一个线性结构。
- “指针”也可以是“引用”（Reference），具体取决于编程语言。

## 2. 链表操作

### 2.1 创建链表

创建链表大致可分为两步：

1. 初始化各个节点对象。
2. 构建节点之间的引用关系。

示例代码（C语言）：

```c
Node* head = (Node*)malloc(sizeof(Node));
Node* second = (Node*)malloc(sizeof(Node));
Node* third = (Node*)malloc(sizeof(Node));

head->data = 1;
head->next = second;

second->data = 2;
second->next = third;

third->data = 3;
third->next = NULL;
```

**通常将头节点当作链表的入口**，通过头节点可以访问链表中的所有节点。

### 2.2 插入节点

插入节点的步骤（比如在n1和n2之间插入一个新节点m）：

1. 创建新节点m，并赋值。
2. 将m的指针域指向n2。
3. 将n1的指针域指向m。

示例代码（C语言）：

```c
Node* m = (Node*)malloc(sizeof(Node));
m->data = 4;
m->next = second;

head->next = m;
```

### 2.3 删除节点

删除节点的步骤（比如删除节点n2）：

1. 找到待删除节点n2的前驱节点n1。
2. 将n1的指针域指向n2的后继节点n3。
3. 释放n2的内存。

示例代码（C语言）：

```c
Node* n1 = head;
Node* n2 = head->next;
Node* n3 = n2->next;

n1->next = n3;
free(n2);
```

### 2.4 访问节点

**访问节点的效率较低**，需要从头节点开始，依次遍历链表，直到找到目标节点。时间复杂度为O(n)。

```c
ListNode *accessNode(ListNode *head, int index) {
    ListNode *current = head;
    int count = 0;
    while (current != NULL) {
        if (count == index) {
            return current;
        }
        count++;
        current = current->next;
    }
    return NULL; // 如果索引超出范围，返回NULL
}
```

### 2.5 查找节点

查找节点的步骤（比如查找值为target的节点）：

1. 从头节点开始，依次遍历链表。
2. 如果找到目标节点，返回该节点的指针。
3. 如果遍历完整个链表仍未找到，返回NULL。

示例代码（C语言）：

```c
ListNode *findNode(ListNode *head, int target) {
    ListNode *current = head;
    while (current != NULL) {
        if (current->data == target) {
            return current;
        }
        current = current->next;
    }
    return NULL; // 如果未找到，返回NULL
}
```

## 3. 链表的类型

常见的链表类型：

- **单向链表**：就是以上所说的基本链表结构，节点只包含值和指向下一个节点的指针。
- **环形链表**：单向链表的尾节点指向头节点，形成一个环，因此任意节点都可以作为入口访问链表。
- **双向链表**：每个节点包含两个指针域，分别指向一前一后的节点，支持双向遍历，但也增加了内存开销。

这些链表类型直观图示如下：

![链表类型示意图](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png)

**双向链表节点定义示例（C语言）**：

```c
typedef struct ListNode {
    int val;
    struct ListNode *next; // 指向下一个节点
    struct ListNode *prev; // 指向前一个节点
} ListNode;

ListNode *newListNode(int val) {
    ListNode *node;
    node = (ListNode *)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;//初始化下一个节点指针为空
    node->prev = NULL;//初始化前一个节点指针为空
    return node;
}
```

## 4. 链表的应用

- **单向链表**：通常用于实现栈、队列、哈希表和图等数据结构。
- **双向链表**：
    - **高级数据结构**：如平衡树、跳表等，利用双向链表的双向遍历特性。
    - **浏览器历史记录**：浏览器中的前进和后退功能通常使用双向链表实现。
    - **LRU缓存**：LRU算法中，需要快速找到最近最少使用的数据，以及快速更新数据的使用顺序，双向链表非常适合这种需求。
- **环形链表**：
    - **时间片轮转调度算法**：操作系统中，环形链表用于实现时间片轮转调度算法，确保每个进程都能公平地获得CPU时间。
    - **数据缓冲区**：环形链表常用于实现循环缓冲区（Circular Buffer），适用于需要连续读写数据的场景，如音频处理、网络数据传输等。

