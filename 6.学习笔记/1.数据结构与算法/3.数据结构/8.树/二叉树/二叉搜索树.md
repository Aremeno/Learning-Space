# 二叉搜索树

## 什么是二叉搜索树

二叉搜索树（Binary Search Tree，BST）需要满足以下条件：

1. 对于根节点，左子树中所有节点的值 < 根节点的值 < 右子树中所有节点的值
2. 左右子树也必须是二叉搜索树

## 二叉搜索树的基本操作

可以将二叉搜索树封装为一个类 `BST`，并声明一个成员变量 `root` 作为根节点。

### 查找节点

查找节点的过程与二叉树类似，但由于二叉搜索树的性质，可以大大减少查找的范围。

```c++
TreeNode* searchBST(int num) {
    TreeNode *cur = root;
    while(cur != nullptr) {
        if(cur->val < num) {
            cur = cur->right;
        }
        else if(cur->val > num) {
            cur = cur->left;
        }
        else {
            break;
        }
    }
    return cur;
}
```

### 插入节点

步骤如下：

1. **查找插入位置**：与查找操作类似，根据当前节点值与插入值的比较，决定向左还是向右移动，直到找到合适的插入位置（即当前节点为空）。
2. **插入节点**：初始化节点，并将其插入到`None`位置。

```c++
void insert(int num) {
    // 处理空树（直接将该节点作为根节点即可）
    if (root == nullptr) {
        root = new TreeNode(num);
        return;
    }
    // 定义遍历节点指针及其父节点
    TreeNode *cur = root,*pre = nullptr;
    // 遍历循环
    while (cur != nullptr) {
        if (cur->val == num)  //找到重复值的情况（二叉树搜索树不允许有重复值）
            return;
        pre = cur; //父节点更新

        // 根据BST特性决定查找方向
        if (cur->val < num) //目标值更大，去右子树
            cur = cur->right;
        else
            cur = cur->left;
    }
    // 插入节点
    TreeNode *node = new TreeNode(num);
    if (pre->val < num)
        pre->right = node;
    else
        pre->left = node;
}
```

### 删除节点

删除节点其实就是先找到目标节点，然后根据其子节点的情况进行删除：

1. **目标节点无子节点**：直接删除即可。
2. **目标节点有一个子节点**：将目标节点的父节点指向目标节点的子节点。
3. **目标节点有两个子节点**：找到目标节点右子树的最小节点（或左子树的最大节点），用该节点的值替换目标节点的值，然后删除该最小节点（或最大节点）。

```c++
void remove(int num) {
    // 处理树为空的情况
    if (root == nullptr) 
        return;
    TreeNode *cur = root, *pre = nullptr;
    while (cur != nullptr) {
        if (cur->val == num)
            break; //找到待删除节点，跳出循环
        pre = cur;
        if (cur->val < num)
            cur = cur->right;
        else
            cur = cur->left;
    }
    if (cur == nullptr)
        return;
    // 子节点数量为0或者1
    if (cur->left == nullptr || cur->right == nullptr) {
        TreeNode *child = cur->left != nullptr ? cur->left : cur->right;
        // 删除节点
        if (cur != root) {
            if (pre->left == cur)
                pre->left = child;
            else
                pre->right = child;
        } else {
            root = child;
        }
        // 释放内存
        delete cur;
    }
    // 子节点数量为2
    else {
        // 获取中序遍历中cur的下个节点
        TreeNode *tmp = cur->right;
        while (tmp->left != nullptr) {
            tmp = tmp->left;
        }
        int temVal = tmp->val;
        // 递归删除节点tmp
        remove(tmp->val);
        // 用tmp覆盖cur
        cur->val = tmpVal;
    }
}