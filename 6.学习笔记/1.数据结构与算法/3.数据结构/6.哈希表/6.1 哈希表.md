# 哈希表

## 什么是哈希表？

哈希表（Hash Table）是一种通过键（key）直接访问值（value）的数据结构。它通过哈希函数将键映射到数组的特定位置，从而实现高效的数据存储和检索。

**核心思想**：通过数学函数（哈希函数）将任意长度的输入（键）转换为固定长度的输出（哈希值），并使用该哈希值作为数组的索引。

## 哈希表的核心组件

1. **哈希函数（Hash Function）**：将键转换成数组索引的函数。一个好的哈希函数应均匀分布键，减少冲突。
2. **冲突解决机制**：当两个键通过哈希函数映射到同一索引时，称为冲突。常见的解决方法有链地址法和开放地址法。

## C语言实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 100

// 哈希表节点

typedef struct HashNode {
    char *key;
    int value;
    struct HashNode *next; //用于处理冲突的链表
} HashNode;

// 哈希表

typedef struct {
    HashNode **buckets;   //桶数组
    int size;    //表大小
} HashTable;

// 复杂的哈希函数（减少冲突）

unsigned int djb2_hash(const char *key,int table_size) {
    unsigned long hash = 5381;
    int c;

    while ((c = *key++)) {
        hash = ((hash << 5) + hash) +c;
    }

    return hash % table_size;
}

// 创建哈希表

HashTable *create_hash_table(int size) {
    HashTable *table = (HashTable *)malloc(sizeof(HashTable));
    table->size = size;
    table->buckets = (HashNode **)calloc(size, sizeof(HashNode *));
    return table;
}

// 插入键值对

void hash_table_insert(HashTable *table,const char *key,int value) {
    unsigned int index = djb2_hash(key,table->size);

    // 检查这个键是否已存在
    HashNode *current = table->buckets[index];
    while(current !=NULL) {
        if(strcmp(current->key,key) == 0) {
            current->value = value;
            return;
        }
        current = current->next;
    }

    // 创建新节点（如果键不存在）
    HashNode *new_node = (HashNode*)malloc(sizeof(HashNode));
    new_node->key = strdup(key); //复制字符串
    new_node->value = value;

    // 头插法
    new_node->next = table->buckets[index];
    table->buckets[index] = new_node;
}

// 查找值

int hash_table_search(HashTable *table,const char *key,int *value) {
    unsigned int index = djb2_hash(key,table->size);
    HashNode *current = table->buckets[index];

    while(current != NULL) {
        if(strcmp(current->key,key) == 0) {
            *value = current->value;
            return 1;   //找到了（返回1）
        }
        current = current->next;
    }

    return 0;  //没找到（返回0）
}

// 删除键值对

int hash_table_delete(HashTable *table,const char *key) {
    unsigned int index = djb2_hash(key,table->size);
    HashNode *current = table->buckets[index];
    HashNode *prev = NULL; //空指针（用于标记）

    while(current != NULL) {
        if(strcmp(current->key,key) == 0) {
            if(prev == NULL) {
                table->buckets[index] = current->next;
            }
            else {
                prev->next = current->next;
            }

            free(current->key);
            free(current);
            return 1;
        }
        prev = current;
        current = current->next;
    }

    return 0;
}

// 打印哈希表

void print_hash_table(HashTable *table) {
    for(int i = 0 ; i < table->size ; i++) {
        HashNode *current = table->buckets[i];
        while (current != NULL) {
            printf("(%s: %d) -> ", current->key, current->value);
            current = current->next;
        }
        printf("NULL\n");
    }

}

void destroy_hash_table(HashTable *table) {
    if (table == NULL) return;
    for (int i = 0; i < table->size; i++ ) {
        HashNode *current = table->buckets[i];
        while(current != NULL) {
            HashNode *temp = current;
            current = current->next;
            free(temp->key);
            free(temp);
        }
    }
    free(table->buckets);
    free(table);
}
```

## C++STL中的哈希表




